# CLustering
## Algorithm 1: K-means Clustering
## Algorithm 2: Hierarchical Clustering
#install.packages("factoextra")
#install.packages("cluster")
#install.packages("magrittr")
#install.packages("NbClust")
library("cluster")
library("factoextra")
library("magrittr")
library("dplyr")
library("NbClust")
# Loading and Preparing Datasets
train <- read.csv('complete_train.csv',sep = ',', header=TRUE)
# Turning every attribute numeric
train <- train %>% mutate(card_num = case_when(card_num == 'none' ~ 0, card_num == 'classic' ~ 1, card_num == 'junior' ~ 2, card_num == 'gold' ~ 3))
train <- train %>% mutate(frequency_num = case_when( frequency_num == 'monthly issuance' ~ 0, frequency_num == 'weekly issuance' ~ 1, frequency_num == 'issuance after transaction' ~ 2))
train <- train %>% mutate(gender = case_when(gender == 'F' ~ -1, gender == 'M' ~ 1))
# Since clustering is unsupervised learning, we need unlabeled data
train <- subset(train, select=-status)
# Subsets to test for clusters
df_clients <- train[,c("age", "gender", "avg_salary")]
df_accounts <- train[c(1:25,38:39)]
df_districts <- train[c(28, 30:36)]
# RFE CHOSEN FEATURES (18)
#"min_balance"       "min_withdrawal"    "median_balance"    "median_credit"     "payments_loan"
#"num_credit"        "avg_amount"        "median_amount"     "iqr_credit"        "min_credit"
#"iqr_balance"       "iqr_withdrawal"    "time_bf_loan"      "age"               "median_withdrawal"
#"unemployment_96"   "duration_loan"     "frequency_num"
df_rfe_var <- train[,c("min_balance", "min_withdrawal", "median_balance", "median_credit", "payments_loan", "num_credit",
"avg_amount", "median_amount", "iqr_credit", "min_credit", "iqr_balance", "iqr_withdrawal",
"time_bf_loan", "age", "median_withdrawal", "unemployment_96", "duration_loan", "frequency_num")]
# BORUTA CHOSEN FEATURES
#"num_credit"        "min_credit"        "median_credit"     "iqr_credit"        "min_withdrawal"
#"median_withdrawal" "iqr_withdrawal"    "avg_amount"        "median_amount"     "min_balance"
#"median_balance"    "iqr_balance"       "time_bf_loan"      "payments_loan"
df_boruta_var <- train[,c("num_credit", "min_credit", "median_credit", "iqr_credit", "min_withdrawal",
"median_withdrawal", "iqr_withdrawal", "avg_amount", "median_amount", "min_balance",
"median_balance", "iqr_balance", "time_bf_loan", "payments_loan")]
# BORUTA ROUGH FIX CHOSEN FEATURES
#"num_credit"     "min_credit"     "median_credit"  "iqr_credit"     "min_withdrawal" "iqr_withdrawal"
#"avg_amount"     "median_amount"  "min_balance"    "median_balance" "time_bf_loan"   "payments_loan"
df_boruta_rf_var <-  train[,c("num_credit", "min_credit", "median_credit", "iqr_credit", "min_withdrawal",
"iqr_withdrawal", "avg_amount", "median_amount", "min_balance",
"median_balance", "time_bf_loan", "payments_loan")]
df_account_stats <-  train[,c("avg_salary", "avg_monthly_balance", "median_balance", "iqr_balance",
"min_balance", "max_balance", "avg_balance", "num_credit", "avg_credit")]
df_loans_stats <-  train[,c("age_at_loan", "duration_loan", "payments_loan", "avg_monthly_balance")]
df_loans_stats$amount_loan <- df_loans_stats$duration_loan * df_loans_stats$payments_loan
df_people <-  train[,c("gender", "age", "avg_salary", "avg_monthly_balance", "avg_balance","avg_amount", "num_credit")]
# df_clients, df_accounts, df_districts, df_rfe_var, df_boruta_var, df_boruta_rf_var, df_account_stats, df_loans_stats
set.seed(100)
## Assessing Cluster Tendencies Before Starting
# Hopkins statistic: If the value of Hopkins statistic is close to 1 (far above 0.5),
# then we can conclude that the dataset is significantly clusterable.
gradient.color <- list(low = "steelblue",  high = "white")
df_clients %>%
scale() %>%
get_clust_tendency(n = 50, gradient = gradient.color)
# $hopkins_stat = 0.8285233
df_districts %>%
scale() %>%
get_clust_tendency(n = 50, gradient = gradient.color)
# $hopkins_stat = 0.6798115
df_accounts %>%
scale() %>%
get_clust_tendency(n = 50, gradient = gradient.color)
# $hopkins_stat = 0.8182907
df_rfe_var %>%
scale() %>%
get_clust_tendency(n = 50, gradient = gradient.color)
# $hopkins_stat = 0.7913022
df_boruta_var %>%
scale() %>%
get_clust_tendency(n = 50, gradient = gradient.color)
# $hopkins_stat = 0.843987
df_boruta_rf_var %>%
scale() %>%
get_clust_tendency(n = 50, gradient = gradient.color)
# $hopkins_stat = 0.8563201
df_account_stats %>%
scale() %>%
get_clust_tendency(n = 50, gradient = gradient.color)
# $hopkins_stat = 0.8561262
df_loans_stats %>%
scale() %>%
get_clust_tendency(n = 50, gradient = gradient.color)
# $hopkins_stat = 0.7374299
df_people %>%
scale() %>%
get_clust_tendency(n = 50, gradient = gradient.color)
# $hopkins_stat = 0.7354357
# We'll be keeping the dataframe that got a hopkins score of >80%
#   = df_boruta_rf_var, df_account_stats, df_boruta_var, df_clients, df_accounts
## Determining the optimal number of clusters
# 2ª forma ?
# (
# gap_stat <- clusGap(df_boruta_rf_var, FUN = kmeans, nstart = 25, K.max = 10, B = 50)
# fviz_gap_stat(gap_stat)
# )
# 3ª forma ?
# fviz_nbclust(df_boruta_rf_var, kmeans, method = "silhouette")
#install.packages("fpc")
#   num_credit min_credit median_credit iqr_credit min_withdrawal iqr_withdrawal avg_amount median_amount min_balance median_balance time_bf_loan payments_loan
#1   28.84456   48.33834      2657.380   15457.22       749.6658       5944.038   916.1461     -217.9956    571.8528       32875.33     9412.611      3695.865
#2   32.65926   67.42963      9774.816   31830.70       482.8230      12655.210  1084.3762     -587.2733    713.5844       54464.95     9606.289      4801.511
###
df_account_stats <-  train[,c("avg_salary", "avg_monthly_balance", "median_balance", "iqr_balance",
"min_balance", "max_balance", "avg_balance", "num_credit", "avg_credit")]
account_stats_nbClusters <- df_account_stats %>%
scale() %>%
NbClust(distance = "euclidean",
min.nc = 2, max.nc = 9,
method = "complete", index ="all")
fviz_nbclust(account_stats_nbClusters, ggtheme = theme_minimal()) # Suggests 3
setwd("C:/Users/xanaf/Desktop/feup/4 ano/1 semestre/ac/repos/AC/dm-proj1")
# CLustering
## Algorithm 1: K-means Clustering
## Algorithm 2: Hierarchical Clustering
#install.packages("factoextra")
#install.packages("cluster")
#install.packages("magrittr")
#install.packages("NbClust")
library("cluster")
library("factoextra")
library("magrittr")
library("dplyr")
library("NbClust")
# Loading and Preparing Datasets
train <- read.csv('complete_train.csv',sep = ',', header=TRUE)
# Turning every attribute numeric
train <- train %>% mutate(card_num = case_when(card_num == 'none' ~ 0, card_num == 'classic' ~ 1, card_num == 'junior' ~ 2, card_num == 'gold' ~ 3))
train <- train %>% mutate(frequency_num = case_when( frequency_num == 'monthly issuance' ~ 0, frequency_num == 'weekly issuance' ~ 1, frequency_num == 'issuance after transaction' ~ 2))
train <- train %>% mutate(gender = case_when(gender == 'F' ~ -1, gender == 'M' ~ 1))
# Since clustering is unsupervised learning, we need unlabeled data
train <- subset(train, select=-status)
# Subsets to test for clusters
df_clients <- train[,c("age", "gender", "avg_salary")]
df_accounts <- train[c(1:25,38:39)]
df_districts <- train[c(28, 30:36)]
# RFE CHOSEN FEATURES (18)
#"min_balance"       "min_withdrawal"    "median_balance"    "median_credit"     "payments_loan"
#"num_credit"        "avg_amount"        "median_amount"     "iqr_credit"        "min_credit"
#"iqr_balance"       "iqr_withdrawal"    "time_bf_loan"      "age"               "median_withdrawal"
#"unemployment_96"   "duration_loan"     "frequency_num"
df_rfe_var <- train[,c("min_balance", "min_withdrawal", "median_balance", "median_credit", "payments_loan", "num_credit",
"avg_amount", "median_amount", "iqr_credit", "min_credit", "iqr_balance", "iqr_withdrawal",
"time_bf_loan", "age", "median_withdrawal", "unemployment_96", "duration_loan", "frequency_num")]
# BORUTA CHOSEN FEATURES
#"num_credit"        "min_credit"        "median_credit"     "iqr_credit"        "min_withdrawal"
#"median_withdrawal" "iqr_withdrawal"    "avg_amount"        "median_amount"     "min_balance"
#"median_balance"    "iqr_balance"       "time_bf_loan"      "payments_loan"
df_boruta_var <- train[,c("num_credit", "min_credit", "median_credit", "iqr_credit", "min_withdrawal",
"median_withdrawal", "iqr_withdrawal", "avg_amount", "median_amount", "min_balance",
"median_balance", "iqr_balance", "time_bf_loan", "payments_loan")]
# BORUTA ROUGH FIX CHOSEN FEATURES
#"num_credit"     "min_credit"     "median_credit"  "iqr_credit"     "min_withdrawal" "iqr_withdrawal"
#"avg_amount"     "median_amount"  "min_balance"    "median_balance" "time_bf_loan"   "payments_loan"
df_boruta_rf_var <-  train[,c("num_credit", "min_credit", "median_credit", "iqr_credit", "min_withdrawal",
"iqr_withdrawal", "avg_amount", "median_amount", "min_balance",
"median_balance", "time_bf_loan", "payments_loan")]
df_account_stats <-  train[,c("avg_salary", "avg_monthly_balance", "median_balance", "iqr_balance",
"min_balance", "max_balance", "avg_balance", "num_credit", "avg_credit")]
df_loans_stats <-  train[,c("age_at_loan", "duration_loan", "payments_loan", "avg_monthly_balance")]
df_loans_stats$amount_loan <- df_loans_stats$duration_loan * df_loans_stats$payments_loan
df_people <-  train[,c("gender", "age", "avg_salary", "avg_monthly_balance", "avg_balance","avg_amount", "num_credit")]
# df_clients, df_accounts, df_districts, df_rfe_var, df_boruta_var, df_boruta_rf_var, df_account_stats, df_loans_stats
set.seed(100)
## Assessing Cluster Tendencies Before Starting
# Hopkins statistic: If the value of Hopkins statistic is close to 1 (far above 0.5),
# then we can conclude that the dataset is significantly clusterable.
gradient.color <- list(low = "steelblue",  high = "white")
df_clients %>%
scale() %>%
get_clust_tendency(n = 50, gradient = gradient.color)
# $hopkins_stat = 0.8285233
df_districts %>%
scale() %>%
get_clust_tendency(n = 50, gradient = gradient.color)
# $hopkins_stat = 0.6798115
df_accounts %>%
scale() %>%
get_clust_tendency(n = 50, gradient = gradient.color)
# $hopkins_stat = 0.8182907
df_rfe_var %>%
scale() %>%
get_clust_tendency(n = 50, gradient = gradient.color)
# $hopkins_stat = 0.7913022
df_boruta_var %>%
scale() %>%
get_clust_tendency(n = 50, gradient = gradient.color)
# $hopkins_stat = 0.843987
df_boruta_rf_var %>%
scale() %>%
get_clust_tendency(n = 50, gradient = gradient.color)
# $hopkins_stat = 0.8563201
df_account_stats %>%
scale() %>%
get_clust_tendency(n = 50, gradient = gradient.color)
# $hopkins_stat = 0.8561262
df_loans_stats %>%
scale() %>%
get_clust_tendency(n = 50, gradient = gradient.color)
# $hopkins_stat = 0.7374299
df_people %>%
scale() %>%
get_clust_tendency(n = 50, gradient = gradient.color)
# $hopkins_stat = 0.7354357
# We'll be keeping the dataframe that got a hopkins score of >80%
#   = df_boruta_rf_var, df_account_stats, df_boruta_var, df_clients, df_accounts
## Determining the optimal number of clusters
# 2ª forma ?
# (
# gap_stat <- clusGap(df_boruta_rf_var, FUN = kmeans, nstart = 25, K.max = 10, B = 50)
# fviz_gap_stat(gap_stat)
# )
# 3ª forma ?
# fviz_nbclust(df_boruta_rf_var, kmeans, method = "silhouette")
#install.packages("fpc")
#   num_credit min_credit median_credit iqr_credit min_withdrawal iqr_withdrawal avg_amount median_amount min_balance median_balance time_bf_loan payments_loan
#1   28.84456   48.33834      2657.380   15457.22       749.6658       5944.038   916.1461     -217.9956    571.8528       32875.33     9412.611      3695.865
#2   32.65926   67.42963      9774.816   31830.70       482.8230      12655.210  1084.3762     -587.2733    713.5844       54464.95     9606.289      4801.511
###
df_account_stats <-  train[,c("avg_salary", "avg_monthly_balance", "median_balance", "iqr_balance",
"min_balance", "max_balance", "avg_balance", "num_credit", "avg_credit")]
account_stats_nbClusters <- df_account_stats %>%
scale() %>%
NbClust(distance = "euclidean",
min.nc = 2, max.nc = 9,
method = "complete", index ="all")
fviz_nbclust(account_stats_nbClusters, ggtheme = theme_minimal()) # Suggests 3
# Cluster Plot
account_stats_km <- kmeans(df_account_stats, 3)
fviz_cluster(account_stats_km, data = df_account_stats,
ellipse = FALSE,
ellipse.type = "convex",
palette = "jco",
ggtheme = theme_minimal(),
show.clust.cent = TRUE,
choose.vars = c("avg_monthly_balance", "avg_credit"),
main="Clusters for Client's Profiles",
xlab="Average monthly balance of the account",
ylab="Average Credit Amount",)
# Cluster's Stats
account_stats_km$centers
boruta_nbClusters <- df_boruta_var %>%
scale() %>%
NbClust(distance = "euclidean",
min.nc = 2, max.nc = 9,
method = "complete", index ="all")
# Hierarchical Dendogram
boruta_rf_hc <- df_boruta_rf_var %>%
scale() %>%
eclust("hclust", k = 2, graph = FALSE)
fviz_dend(boruta_rf_hc, palette = "jco",
rect = TRUE, show_labels = FALSE)
# Silhouette Diagram
fviz_silhouette(boruta_rf_hc)
# Silhouette width of observations
sil_boruta_rf <- boruta_rf_hc$silinfo$widths[, 1:3]
# Objects with negative silhouette
neg_sil_index_boruta_rf <- which(sil_boruta_rf[, 'sil_width'] < 0)
sil_boruta_rf[neg_sil_index_boruta_rf, , drop = FALSE]
# Hierarchical Dendogram
account_stats_hc <- df_account_stats %>%
scale() %>%
eclust("hclust", k = 2, graph = FALSE)
fviz_dend(account_stats_hc, palette = "jco",
rect = TRUE, show_labels = FALSE)
# Silhouette Diagram
fviz_silhouette(account_stats_hc)
boruta_hc <- df_boruta_var %>%
scale() %>%
eclust("hclust", k = 2, graph = FALSE)
fviz_dend(boruta_hc, palette = "jco",
rect = TRUE, show_labels = FALSE)
# Silhouette Diagram
fviz_silhouette(boruta_hc)
clients_hc <- df_clients %>%
scale() %>%
eclust("hclust", k = 9, graph = FALSE)
fviz_dend(clients_hc, palette = "jco",
rect = TRUE, show_labels = FALSE)
# Silhouette Diagram
fviz_silhouette(clients_hc)
